<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>openraft</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The openraft user guide.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="cluster-controls.html"><strong aria-hidden="true">2.</strong> Cluster Controls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cluster-formation.html"><strong aria-hidden="true">2.1.</strong> Cluster Formation</a></li><li class="chapter-item expanded "><a href="dynamic-membership.html"><strong aria-hidden="true">2.2.</strong> Dynamic Membership</a></li></ol></li><li class="chapter-item expanded "><a href="metrics.html"><strong aria-hidden="true">3.</strong> Metrics</a></li><li class="chapter-item expanded "><a href="internal.html"><strong aria-hidden="true">4.</strong> Internal</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">4.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="threading.html"><strong aria-hidden="true">4.2.</strong> Threads</a></li><li class="chapter-item expanded "><a href="replication.html"><strong aria-hidden="true">4.3.</strong> Replication</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">openraft</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="openraft"><a class="header" href="#openraft">Openraft</a></h1>
<strong>
    Advanced <a href="https://raft.github.io/">Raft</a> using <a href="https://tokio.rs/">the Tokio framework</a>. Please ‚≠ê on <a href="https://github.com/datafuselabs/openraft">github</a>!
</strong>
<hr />
<p><a href="https://github.com/datafuselabs/openraft/actions/workflows/ci.yaml"><img src="https://github.com/datafuselabs/openraft/actions/workflows/ci.yaml/badge.svg" alt="CI" /></a>
<a href="https://crates.io/crates/openraft"><img src="https://img.shields.io/crates/v/openraft.svg" alt="Crates.io" /></a>
<a href="https://docs.rs/openraft"><img src="https://docs.rs/openraft/badge.svg" alt="docs.rs" /></a>
<a href="LICENSE"><img src="https://img.shields.io/badge/license-MIT%2FApache--2.0-blue" alt="License" /></a>
<img src="https://img.shields.io/crates/d/openraft.svg" alt="Crates.io" />
<img src="https://img.shields.io/crates/dv/openraft.svg" alt="Crates.io" /></p>
<p>Raft is not yet good enough.
This project intends to improve raft as the next generation consensus protocol for distributed data storage systems (SQL, NoSQL, KV, Streaming, Graph ... or maybe something more exotic).</p>
<p>Currently openraft is the consensus engine of meta-service cluster in <a href="https://github.com/datafuselabs/databend">databend</a>.</p>
<ul>
<li>
<p><strong>Get started</strong>: <a href="https://datafuselabs.github.io/openraft">The guide</a> is the best place to get started,
followed by <a href="https://docs.rs/openraft/latest/">the docs</a> for more in-depth details.</p>
</li>
<li>
<p><strong>Openraft API is not stable yet.</strong> Before <code>1.0.0</code>, an upgrade may contain incompatible changes.
Check our <a href="https://github.com/datafuselabs/openraft/blob/main/change-log.md">change-log</a></p>
</li>
<li>
<p>Openraft is derived from <a href="https://docs.rs/crate/async-raft/latest">async-raft</a> with several bugs fixed:</p>
</li>
</ul>
<details>
  <summary>List of fixed bugs:</summary>
<ul>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/6c0ccaf3ab3f262437d8fc021d4b13437fa4c9ac">6c0ccaf3</a> consider joint config when starting up and committing.; by drdr xp; 2021-12-24</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/228077a66d5099fd404ae9c68f0977e5f978f102">228077a6</a> a restarted follower should not wait too long to elect. Otherwise, the entire cluster hangs; by drdr xp; 2021-11-19</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/a48a3282c58bdcae3309545a06431aecf3e65db8">a48a3282</a> handle-vote should compare last_log_id in dictionary order, not in vector order; by drdr xp; 2021-09-09</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/eed681d57950fc58b6ca71a45814b8f6d2bb1223">eed681d5</a> race condition of concurrent snapshot-install and apply.; by drdr xp; 2021-09-01</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/9540c904da4ae005baec01868e01016f3bc76810">9540c904</a> when append-entries, deleting entries after prev-log-id causes committed entry to be lost; by drdr xp; 2021-08-31</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/6d53aa12f66ecd08e81bcb055eb17387b835e2eb">6d53aa12</a> too many(50) inconsistent log should not live lock append-entries; by drdr xp; 2021-08-31</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/4d58a51e41189acba06c1d2a0e8466759d9eb785">4d58a51e</a> a non-voter not in joint config should not block replication; by drdr xp; 2021-08-31</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/8cd24ba0f0212e94e61f21a7be0ce0806fcc66d5">8cd24ba0</a> RaftCore.entries_cache is inconsistent with storage. removed it.; by drdr xp; 2021-08-23</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/2eccb9e1f82f1bf71f6a2cf9ef6da7bf6232fa84">2eccb9e1</a> install snapshot req with offset GE 0 should not start a new session.; by drdr xp; 2021-08-22</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/eee8e534e0b0b9abdb37dd94aeb64dc1affd3ef7">eee8e534</a> snapshot replication does not need to send a last 0 size chunk; by drdr xp; 2021-08-22</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/beb0302b4fec0758062141e727bf1bbcfd4d4b98">beb0302b</a> leader should not commit when there is no replication to voters.; by drdr xp; 2021-08-18</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/dba24036cda834e8c970d2561b1ff435afd93165">dba24036</a> after 2 log compaction, membership should be able to be extract from prev compaction log; by drdr xp; 2021-07-14</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/447dc11cab51fb3b1925177d13e4dd89f998837b">447dc11c</a> when finalize_snapshot_installation, memstore should not load membership from its old log that are going to be overridden by snapshot.; by drdr xp; 2021-07-13</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/cf4badd0d762757519e2db5ed2f2fc65c2f49d02">cf4badd0</a> leader should re-create and send snapshot when <code>threshold/2 &lt; last_log_index - snapshot &lt; threshold</code>; by drdr xp; 2021-07-08</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/d60f1e852d3e5b9455589593067599d261f695b2">d60f1e85</a> client_read has using wrong quorum=majority-1; by drdr xp; 2021-07-02</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/11cb5453e2200eda06d26396620eefe66b169975">11cb5453</a> doc-include can only be used in nightly build; by drdr xp; 2021-06-16</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/a10d99066b8c447d7335c7f34e08bd78c4b49f61">a10d9906</a> when handle_update_match_index(), non-voter should also be considered, because when member change a non-voter is also count as a quorum member; by drdr xp; 2021-06-16</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/d882e743db4734b2188b137ebf20c0443cf9fb49">d882e743</a> when calc quorum, the non-voter should be count; by drdr xp; 2021-06-02</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/6202138f0766dcfd07a1a825af165f132de6b920">6202138f</a> a conflict is expected even when appending empty entries; by drdr xp; 2021-05-24</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/f449b64aa9254d9a18bc2abb5f602913af079ca9">f449b64a</a> discarded log in replication_buffer should be finally sent.; by drdr xp; 2021-05-22</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/6d680484ee3e352d4caf37f5cd6f57630f46d9e2">6d680484</a> #112 : when a follower is removed, leader should stop sending log to it.; by drdr xp; 2021-05-21</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/89bb48f8702762d33b59a7c9b9710bde4a97478c">89bb48f8</a> last_applied should be updated only when logs actually applied.; by drdr xp; 2021-05-20</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/39690593a07c6b9ded4b7b8f1aca3191fa7641e4">39690593</a> a NonVoter should stay as NonVoter instead of Follower after restart; by drdr xp; 2021-05-14</li>
</ul>
<p>A full list of changes/fixes can be found in <a href="https://github.com/datafuselabs/openraft/blob/main/change-log.md">change-log</a></p>
</details>
<h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<ul>
<li><input disabled="" type="checkbox"/>
<p>Support only one membership-change algo: joint; </p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Reduce the complexity of vote and pre-vote: <a href="https://github.com/datafuselabs/openraft/discussions/15">get rid of pre-vote RPC</a>;</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Reduce confliction rate when electing;
Allow leadership to be taken in one term by a node with greater node-id.</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Support flexible quorum, e.g.:<a href="https://zookeeper.apache.org/doc/r3.5.9/zookeeperHierarchicalQuorums.html">Hierarchical Quorums</a></p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Consider introducing read-quorum and write-quorum,
improve efficiency with a cluster with an even number of nodes.</p>
</li>
</ul>
<!--
   - - [ ] Consider to separate log storage and log order storage.
   -   Leader only determines and replicates the index of log entries, not log
   -   payload.
   -->
<h1 id="features"><a class="header" href="#features">Features</a></h1>
<ul>
<li>
<p>It is fully reactive and embraces the async ecosystem.
It is driven by actual Raft events taking place in the system as opposed to being driven by a <code>tick</code> operation.
Batching of messages during replication is still used whenever possible for maximum throughput.</p>
</li>
<li>
<p>Storage and network integration is well defined via two traits <code>RaftStorage</code> &amp; <code>RaftNetwork</code>.
This provides applications maximum flexibility in being able to choose their storage and networking mediums.</p>
</li>
<li>
<p>All interaction with the Raft node is well defined via a single public <code>Raft</code> type, which is used to spawn the Raft async task, and to interact with that task.
The API for this system is clear and concise.</p>
</li>
<li>
<p>Log replication is fully pipelined and batched for optimal performance.
Log replication also uses a congestion control mechanism to help keep nodes up-to-date as efficiently as possible.</p>
</li>
<li>
<p>It fully supports dynamic cluster membership changes with joint config.
The buggy single-step membership change algo is not considered.
See the <a href="https://datafuselabs.github.io/openraft/dynamic-membership.html"><code>dynamic membership</code></a> chapter in the guide.</p>
</li>
<li>
<p>Details on initial cluster formation, and how to effectively do so from an application's perspective,
are discussed in the <a href="https://datafuselabs.github.io/openraft/cluster-formation.html">cluster formation</a> chapter in the guide.</p>
</li>
<li>
<p>Automatic log compaction with snapshots, as well as snapshot streaming from the leader node to follower nodes is fully supported and configurable.</p>
</li>
<li>
<p>The entire code base is <a href="https://docs.rs/tracing/">instrumented with tracing</a>.
This can be used for <a href="https://docs.rs/tracing/latest/tracing/index.html#log-compatibility">standard logging</a>, or for <a href="https://docs.rs/tracing/latest/tracing/index.html#related-crates">distributed tracing</a>, and the verbosity can be <a href="https://docs.rs/tracing/latest/tracing/level_filters/index.html">statically configured at compile time</a> to completely remove all instrumentation below the configured level.</p>
</li>
</ul>
<h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Check out the <a href="https://github.com/datafuselabs/openraft/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a> guide for more details on getting started with contributing to this project.</p>
<h1 id="license"><a class="header" href="#license">License</a></h1>
<p>Openraft is licensed under the terms of the MIT License or the Apache License 2.0, at your choosing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Raft is a distributed consensus protocol designed to manage a replicated log containing state machine commands from clients.</p>
<p>
    <img style="max-width:600px;" src="./images/raft-overview.png"/>
</p>
<p>Raft includes two major parts:</p>
<ul>
<li>How to replicate logs consistently among nodes,</li>
<li>and how to consume the logs, which is defined mainly in state machine.</li>
</ul>
<p>To implement your own raft based application with openraft is quite easy, which
includes: </p>
<ul>
<li>Define client request and response;</li>
<li>Implement a storage to let raft store its state;</li>
<li>Implement a network layer for raft to transmit messages.</li>
</ul>
<h2 id="define-client-request-and-response"><a class="header" href="#define-client-request-and-response">Define client request and response</a></h2>
<p>A request is some data that modifies the raft state machine.
A response is some data that the raft state machine returns to client.</p>
<p>Request and response can be any types that impl <code>AppData</code> and <code>AppDataResponse</code>,
e.g.:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ClientRequest {/* fields */}
impl AppData for ClientRequest {}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ClientResponse(Result&lt;Option&lt;String&gt;, ClientError&gt;);
impl AppDataResponse for ClientResponse {}
<span class="boring">}
</span></code></pre></pre>
<p>These two types are totally application specific, and are mainly related to the
state machine implementation in <code>RaftStorage</code>.</p>
<h2 id="implement-raftstorage"><a class="header" href="#implement-raftstorage">Implement RaftStorage</a></h2>
<p>The trait <code>RaftStorage</code> defines the way that data is stored and consumed.
It could be a wrapper of some local KV store such <a href="https://docs.rs/rocksdb/latest/rocksdb/">RocksDB</a>,
or a wrapper of a remote sql DB.</p>
<p><code>RaftStorage</code> defines 4 sets of APIs:</p>
<ul>
<li>Read/write raft state, e.g., term or vote.</li>
<li>Read/write logs.</li>
<li>Apply log entry to the state machine.</li>
<li>Building and installing a snapshot.</li>
</ul>
<h3 id="how-do-i-impl-raftstorage-correctly"><a class="header" href="#how-do-i-impl-raftstorage-correctly">How do I impl RaftStorage correctly</a></h3>
<ul>
<li>
<p>The APIs have been made quite obvious and there is a good example
<a href="https://github.com/datafuselabs/openraft/tree/main/memstore"><code>memstore</code></a>,
which is a pure-in-memory implementation that shows what should be done when a
method is called.</p>
</li>
<li>
<p>There is a test suite for <code>RaftStorage</code> impl, if an impl passes the test,
Openraft will work happily with it.</p>
<p><a href="https://github.com/datafuselabs/openraft/blob/main/memstore/src/test.rs">Test suite for RaftStorage impl</a></p>
<p>TODO(xp): move this test suite to openraft crate so that users can include it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO(xp): give a example how to test an impl of RaftStorage
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h3 id="race-condition-about-raftstorage"><a class="header" href="#race-condition-about-raftstorage">Race condition about RaftStorage</a></h3>
<p>In our design, there is at most one thread at a time writing data to it.
But there may be several threads reading from it concurrently,
e.g., more than one replication tasks reading log entries from store.</p>
<h3 id="an-implementation-has-to-guarantee-data-durability"><a class="header" href="#an-implementation-has-to-guarantee-data-durability">An implementation has to guarantee data durability</a></h3>
<p>The caller always assumes a completed write is persistent.
The raft correctness highly depends on a reliable store.</p>
<h2 id="impl-raftnetwork"><a class="header" href="#impl-raftnetwork">impl <code>RaftNetwork</code></a></h2>
<p>Raft nodes need to communicate with each other to achieve consensus about the
logs.
The trait <code>RaftNetwork</code> defines the data transmission requirements.</p>
<p>An implementation of <code>RaftNetwork</code> can be considered as a wrapper that invokes the
corresponding methods of a remote <code>Raft</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait RaftNetwork&lt;D&gt;: Send + Sync + 'static
where D: AppData
{
    async fn send_append_entries(&amp;self, target: NodeId, rpc: AppendEntriesRequest&lt;D&gt;) -&gt; Result&lt;AppendEntriesResponse&gt;;
    async fn send_install_snapshot( &amp;self, target: NodeId, rpc: InstallSnapshotRequest,) -&gt; Result&lt;InstallSnapshotResponse&gt;;
    async fn send_vote(&amp;self, target: NodeId, rpc: VoteRequest) -&gt; Result&lt;VoteResponse&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>A mock impl in our tests explains what the impl has to do:
<a href="https://github.com/datafuselabs/openraft/blob/main/openraft/tests/fixtures/mod.rs">fixture: mock impl RaftNetwork</a></p>
<p>As a real world impl, you may want to use <a href="https://github.com/hyperium/tonic">Tonic gRPC</a>.
<a href="https://github.com/datafuselabs/databend/blob/6603392a958ba8593b1f4b01410bebedd484c6a9/metasrv/src/network.rs#L89">databend-meta</a> would be a nice real world example.</p>
<h2 id="put-everything-together"><a class="header" href="#put-everything-together">Put everything together</a></h2>
<p>Finally we put these part together and boot up a raft node:</p>
<pre><pre class="playground"><code class="language-rust">/// The application data request type which the `MemStore` works with.
///
/// Conceptually, for demo purposes, this represents an update to a client's status info,
/// returning the previously recorded status.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ClientRequest {
    /// The ID of the client which has sent the request.
    pub client: String,
    /// The serial number of this request.
    pub serial: u64,
    /// A string describing the status of the client. For a real application, this should probably
    /// be an enum representing all of the various types of requests / operations which a client
    /// can perform.
    pub status: String,
}
impl AppData for ClientRequest {}

/// The application data response type which the `MemStore` works with.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ClientResponse(Result&lt;Option&lt;String&gt;, ClientError&gt;);
impl AppDataResponse for ClientResponse {}

/// A type which emulates a network transport and implements the `RaftNetwork` trait.
pub struct RaftRouter {
    // ... some internal state ...
}

#[async_trait]
impl RaftNetwork&lt;ClientRequest&gt; for RaftRouter {
    /// Send an AppendEntries RPC to the target Raft node (¬ß5).
    async fn append_entries(&amp;self, target: u64, rpc: AppendEntriesRequest&lt;ClientRequest&gt;) -&gt; Result&lt;AppendEntriesResponse&gt; {
        // ... snip ...
    }

    /// Send an InstallSnapshot RPC to the target Raft node (¬ß7).
    async fn install_snapshot(&amp;self, target: u64, rpc: InstallSnapshotRequest) -&gt; Result&lt;InstallSnapshotResponse&gt; {
        // ... snip ...
    }

    /// Send a RequestVote RPC to the target Raft node (¬ß5).
    async fn vote(&amp;self, target: u64, rpc: VoteRequest) -&gt; Result&lt;VoteResponse&gt; {
        // ... snip ...
    }
}

#[async_trait]
impl RaftStorage&lt;ClientRequest, ClientResponse&gt; for MemStore {
    type Snapshot = Cursor&lt;Vec&lt;u8&gt;&gt;;

    async fn get_membership_config(&amp;self) -&gt; Result&lt;MembershipConfig&gt; {
        // ... snip ...
    }

    async fn get_initial_state(&amp;self) -&gt; Result&lt;InitialState&gt; {
        // ... snip ...
    }

    // ... snip ...
}

#[tokio::main]
async fn main() {
    // Get our node's ID from stable storage.
    let node_id = get_id_from_storage().await;

    // Build our Raft runtime config, then instantiate our
    // RaftNetwork &amp; RaftStorage impls.
    let config = Arc::new(Config::build(&quot;primary-raft-group&quot;.into())
        .validate()
        .expect(&quot;failed to build Raft config&quot;));
    let network = Arc::new(RaftRouter::new(config.clone()));
    let storage = Arc::new(MemStore::new(node_id));

    // Create a new Raft node, which spawns an async task which
    // runs the Raft core logic. Keep this Raft instance around
    // for calling API methods based on events in your app.
    let raft = Raft::new(node_id, config, network, storage);

    let resp = raft.client_write(ClientWriteRequest::new(req)).await?;
}

</code></pre></pre>
<p>Now it is time to write something to the cluster.
As we did in our tests with <code>Raft::client_write()</code>:
<a href="https://github.com/datafuselabs/openraft/blob/main/openraft/tests/client_writes.rs">client_writes</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cluster-controls"><a class="header" href="#cluster-controls">Cluster Controls</a></h1>
<p>A raft cluster may be controlled in various ways using the API methods of the <code>Raft</code> type.
This allows the application to influence the raft behavior.</p>
<p>There are several concepts related to cluster control:</p>
<ul>
<li>
<p>Voter: a raft node that is responsible to vote, elect itself for leadership(Candidate),
become Leader or Follower</p>
</li>
<li>
<p>Candidate: a node tries to elect itself as the Leader.</p>
</li>
<li>
<p>Leader: the only node in a cluster that deals with application request.</p>
</li>
<li>
<p>Follower: a node that believes there is a legal leader and just receives
replicated logs.</p>
</li>
<li>
<p>Learner: a node that is not allow to vote but only receives logs.</p>
</li>
</ul>
<p>Voter state transition:</p>
<pre><code>                         vote granted by a quorum
          .--&gt; Candidate ----------------------&gt; Leader
heartbeat |     |                                  |
timeout   |     | seen a higher Leader             | seen a higher Leader
          |     v                                  |
          '----Follower &lt;--------------------------'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cluster-formation"><a class="header" href="#cluster-formation">Cluster Formation</a></h1>
<p>A <code>Raft</code> node enters <code>Learner</code> state when it is created by <code>Raft::new()</code>.</p>
<p>To form a cluster, application must call <code>Raft::initialize(membership)</code>.</p>
<h2 id="raftinitialize"><a class="header" href="#raftinitialize"><code>Raft::initialize()</code></a></h2>
<p>This method will:</p>
<ul>
<li>
<p>Update the in-memory membership.</p>
</li>
<li>
<p>If there are more than one voters in the config, enter Candidate state and start vote to become leader.</p>
</li>
<li>
<p>If there is only one voters(itself) in the config, become leader at once and
will enter leader state.</p>
</li>
<li>
<p>The leader will commit a log contains the given membership config.</p>
</li>
</ul>
<p>TODO(xp): this procedure will be changed:  https://github.com/datafuselabs/openraft/issues/45</p>
<ul>
<li>
<p>Calling this method on an already initialized node just returns an error and is safe.</p>
</li>
<li>
<p>Calling this method on more than one node at the same time:</p>
<ul>
<li>
<p>with the same <code>membership</code> is safe.
Because voting protocol guarantees consistency.</p>
</li>
<li>
<p>with different <code>membership</code> is <strong>ILLEGAL</strong> and will result in a undefined
state, AKA the <strong>split-brain</strong> state.</p>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-membership"><a class="header" href="#dynamic-membership">Dynamic Membership</a></h1>
<p>This impl of <code>Raft</code> offers a more flexible way to deal with cluster management:</p>
<p>It offers only one cluster membership: the <strong>joint</strong> membership.
<strong>Joint</strong> membership is no more an ephemeral state but instead, a normal
long lasting config for a cluster.</p>
<p>A uniform config is just a special case.</p>
<blockquote>
<p>This way it offers flexible cluster management such as hierarchical
membership config that is aware of data-center layout, e.g., 
<code>[{a, b, c}, {u, v, w}, {x, y, z}]</code> is a cluster with 9 nodes, every 3 nodes
forms a group(which in real world, a data center.).
And the quorum of such a cluster is majority of 3 groups, in which
a majority is constituted, e.g, <code>[{a, b}, {u, v}]</code> is a quorum.</p>
</blockquote>
<hr />
<p>Openraft offers 2 mechanisms for controlling member node lifecycle.</p>
<h2 id="raftadd_learner"><a class="header" href="#raftadd_learner"><code>Raft::add_learner()</code></a></h2>
<p>This method will add a learner to the cluster,
and immediately begin syncing logs from the leader.</p>
<ul>
<li>
<p>A <strong>Learner</strong> won't vote for leadership.</p>
</li>
<li>
<p>A <strong>Learner</strong> is not persistently stored by <code>Raft</code>, i.e., if a new leader is
elected, a Learner will no longer receive logs from the new leader.</p>
<p>TODO(xp): store learners in <code>MembershipConfig</code>.</p>
</li>
</ul>
<h2 id="raftchange_membership"><a class="header" href="#raftchange_membership"><code>Raft::change_membership()</code></a></h2>
<p>This method will initiate a membership change.</p>
<p>If there are nodes in the given config that is not a learner, this method will add it
as Learner first.
Thus it is recommended that application always call <code>Raft::add_learner</code> first.
Otherwise <code>change_membership</code> may block for long before committing the
given membership and return.</p>
<p>The new membership config specified by this method will take effect at once.</p>
<p>Once the new config is committed, a Voter that is not in the new config will
revert to a Learner and is ready to remove.</p>
<p>Correctness constrains:</p>
<ul>
<li>
<p>There is no uncommitted membership config on the leader.</p>
</li>
<li>
<p>The new config has to contains a group that is the same as one of the last
committed config.</p>
<p>E.g., the last committed one is <code>[{a, b, c}]</code>, then a legal new config may be:
a joint config: <code>[{a, b, c}, {x, y, z}]</code>.</p>
<p>If the last committed one is <code>[{a, b, c}, {x, y, z}]</code>, a legal new config
may be: <code>[{a, b, c}]</code>, or <code>[{x, y, z}]</code>.</p>
</li>
</ul>
<p>If the constrains are not satisfied, an error is returned and nothing is done
except the learner will not be removed.</p>
<p>TODO(xp): these constrains can be loosen, if raft stores the commit index.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics"><a class="header" href="#metrics">Metrics</a></h1>
<p><code>Raft</code> exports metrics on its internal state via <code>Raft::metrics() -&gt; watch::Receiver&lt;RaftMetrics&gt;</code>.</p>
<p><code>RaftMetrics</code> contains useful information such as:</p>
<ul>
<li>role of this raft node,</li>
<li>the current leader,</li>
<li>last, committed, applied log.</li>
<li>replication state, if this node is a Leader,</li>
<li>snapshot state,</li>
</ul>
<p>Metrics can be used as a trigger of application events, as a monitoring data
source, etc.</p>
<p>Metrics is not a stream thus it only guarantees to provide the latest state but
not every change of the state.
Because internally, <code>watch::channel()</code> only stores one state.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal"><a class="header" href="#internal">Internal</a></h1>
<p>In this chapter we explains how openraft internally works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<pre><code>
        ...................................
        .          User                   .
        .          ‚Äñ                      .
        .          ‚Äñ                      .
        .          ‚Äñ                      .
        .          ‚Äñ client_write(impl AppData) -&gt; impl AppDataResponse
        .          ‚Äñ client_read()        .
        .          ‚Äñ add_learner()      .
        .          ‚Äñ change_membership()      .
        .          v                      .
        .          Raft                   .             .-------------&gt; Raft -----.
        ...................................             |                         |
                   |                                    |                         |
                   | enum RaftMes                       |                         |
                   |                                    |                         |
           ........|................................    |                         |
           .       v                               .    | RPC:                    v
.================= RaftCore                        .    |   vote()                RaftCore
‚Äñ          .       .==+========.                   .    |   append_entries()      
‚Äñ          .       v           v                   .    |   install_snapshot()
‚Äñ          . ReplicationState  ReplicationState    .    |   
‚Äñ          ...|................|....................    |
‚Äñ             |                |                        |
‚Äñ             |                |                        |
‚Äñ  ...........|...........  ...|....................    |
‚Äñ  .          v          .  .  v                   .    |
‚Äñ  . ReplicationStream   .  .  ReplicationStream   .    |
‚Äñ  . ‚Äñ                   .  .  ‚Äñ  ‚Äñ                .    |
‚Äñ  ..‚Äñ....................  .  ‚Äñ  ‚Äñ                .    |
‚Äñ    ‚Äñ                      .  ‚Äñ  v                .    |
‚Äñ    ‚Äñ                      .  ‚Äñ  Arc&lt;RaftNetwork&gt; -----'
‚Äñ    ‚Äñ                      ...‚Äñ....................
‚Äñ    ‚Äñ                         ‚Äñ
‚Äñ    `=========================+ 
‚Äñ                              ‚Äñ get_log()
‚Äñ                              ‚Äñ ...
‚Äñ                              v
`======================&gt; Arc&lt;RaftStorage&gt;
   append_log()                ‚Äñ
   ...                         ‚Äñ
                               v
                           local-disk
                                
 
 -----------------------------------------------              ----------------------------------------------- 
 Node 1                                                       Node 2                                          

</code></pre>
<p>Legends:</p>
<pre><code>..............
. tokio task .
..............

=&gt; function call
-&gt; async communication: through channel or RPC
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threadstasks"><a class="header" href="#threadstasks">Threads(tasks)</a></h1>
<p>There are several threads, AKA tokio-tasks in this raft impl:</p>
<ul>
<li>
<p>RaftCore: all logs and state machine operations are done in this thread.
Thus there is no race condition</p>
<ul>
<li>All raft state runs in this task, such as LeaderState, CandidateState etc.</li>
<li>All write to store is done in this task, i.e., write to store is serialized.</li>
</ul>
<p>Lifecycle:</p>
<ul>
<li>RaftCore thread is spawnd when a raft node is created and keeps running until
the raft node is dropped.</li>
</ul>
</li>
<li>
<p>Replication tasks:</p>
<p>There is exactly one replication task spawned for every replication target,
i.e., a follower or learner.</p>
<p>A replication task replicates logs or snapshot to its target.
A replication thread do not write logs or state machine, but only read from it.</p>
<p>Lifecycle:</p>
<ul>
<li>
<p>A replication task is spawned when RaftCore enters <code>LeaderState</code>, or a leader
target is added by user.</p>
</li>
<li>
<p>A replication task is dropped when a follower of learner is removed by
<strong>change-membership</strong> or when RaftCore quits <code>LeaderState</code>.</p>
</li>
</ul>
</li>
<li>
<p>Snapshot building task:</p>
<p>When RaftCore receives a RaftMsg that requires a snapshot, which is sent by a
<strong>replication task</strong>, RaftCore spawns a sub task to build a snapshot.</p>
<p>Lifecycle:</p>
<ul>
<li>It is spawned when a snapshot is requested,
and is dropped at once when the snapshot is ready.</li>
</ul>
</li>
<li>
<p>User application runs in another task that spawns RaftCore task.</p>
</li>
</ul>
<h1 id="communication-between-tasks"><a class="header" href="#communication-between-tasks">Communication between tasks</a></h1>
<p>All tasks communicate with channels:</p>
<pre><code>User
|
| write;
| change_membership;
| ...
|
|                     new log to
|                     replicate;
`---------&gt; RaftCore -------------+-&gt; Replication -.
            ^  ^                  |                |
            |  |                  `-&gt; Replication -+
            |  |                                   |
            |  `-----------------------------------'
            |      update replication state;
            |      need snapshot;
            |
            |
            | snapshot is ready;
            |
            Build-snapshot

</code></pre>
<ul>
<li>
<p>User to RaftCore: <code>Raft</code> sends <code>RaftMsg</code> though <code>Raft.tx_api</code> to <code>RaftCore</code>,
along with a channel for <code>RaftCore</code> to send back response.</p>
</li>
<li>
<p>RaftCore to Replication: <code>RaftCore</code> stores a channel for every repliation
task.
The messages sent to replication task includes:</p>
<ul>
<li>a new log id to replicate,</li>
<li>and the index the leader has committed.</li>
</ul>
</li>
<li>
<p>Replication to RaftCore:</p>
<ul>
<li>
<p>Replication task sends the already replicated log id
to RaftCore through another per-replication channel.</p>
</li>
<li>
<p>Replication task sends a <code>NeedSnapshot</code> request through the same channel to
ask RaftCore to build a snapshot if there is no log a follower/learner
needs.</p>
</li>
</ul>
</li>
<li>
<p>Build-snapshot to RaftCore: RaftCore spawn a separate task to build a snapshot
asynchronously. When finished, the spawned task sends to RaftCore a message
including the snapshot info.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="replication"><a class="header" href="#replication">Replication</a></h1>
<p>Appending entry is the only RPC to replicate logs from leader to followers or learners.
Installing a snapshot can be seen as a special form of <strong>appending logs</strong>.</p>
<h2 id="append-entry"><a class="header" href="#append-entry">Append-entry</a></h2>
<p>Raft logs can be together seen as a <strong>single value</strong>:
An append-entry RPC forwards all logs to a follower and replace all the logs on the follower.
This way it guarantees committed log can always been seen by next leader.</p>
<p>Although in practice, it is infeasible sending all the logs in one RPC.
Thus, the receiving end in the algorithm becomes:</p>
<ul>
<li>Proceed only when <code>prev_log_id</code> matches local log id at the same <code>index</code>.</li>
<li>Save every log entry into local store if:
<ul>
<li>the entry at the target index is empty.</li>
<li>the entry at the target index is the same as the input one.
Otherwise, there is an <strong>inconsistent</strong> entry,
the follower must delete all entries since this one before storing the input one.</li>
</ul>
</li>
</ul>
<h3 id="why-need-to-delete"><a class="header" href="#why-need-to-delete">Why need to delete</a></h3>
<p>The following diagram shows only log term.</p>
<pre><code class="language-text">R1 5
R2 5
R3 5 3 3
R4
R5 2 4 4
</code></pre>
<p>If log 5 is committed by R1, and log 3 is not removed, R5 in future could become a new leader and overrides log
5 on R3.</p>
<h3 id="caveat-deleting-all-entries-after-prev_log_id-get-committed-log-lost"><a class="header" href="#caveat-deleting-all-entries-after-prev_log_id-get-committed-log-lost">Caveat: deleting all entries after <code>prev_log_id</code> get committed log lost</a></h3>
<p>One of the mistake is to delete all entries after <code>prev_log_id</code> when a matching <code>prev_log_id</code> is found, e.g.:</p>
<pre><code>fn handle_append_entries(req) {
    if store.has(req.prev_log_id) {
        store.delete_logs(req.prev_log_id.index..)
        store.append_logs(req.entries)
    }
}

</code></pre>
<p>This results in loss of committed entry, because deleting and appending are not atomically executed.</p>
<p>E.g., the log entries are as following and R1 now is the leader:</p>
<pre><code class="language-text">R1 1,1  1,2  1,3
R2 1,1  1,2
R3
</code></pre>
<p>When the following steps take place, committed entry <code>{1,2}</code> is lost:</p>
<ul>
<li>R1 to R2: <code>append_entries(entries=[{1,2}, {1,3}], prev_log_id={1,1})</code></li>
<li>R2 deletes <code>{1,2}</code></li>
<li>R2 crash</li>
<li>R2 elected as leader and only see <code>{1,1}</code>; the committed entry <code>{1,2}</code> is lost.</li>
</ul>
<p><strong>The safe way is to skip every entry that present in append-entries message then delete only the
inconsistent entries</strong>.</p>
<h3 id="caveat-commit-index-must-not-advance-the-last-known-consistent-log"><a class="header" href="#caveat-commit-index-must-not-advance-the-last-known-consistent-log">Caveat: commit-index must not advance the last known consistent log</a></h3>
<p>Because we can not just delete <code>log[prev_log_id.index..]</code>, (which results in loss of committed
entry), the commit index must be updated only after append-entries
and must point to a log entry that is consistent to the leader.
Or there would be chance applying an uncommitted entry on a follower:</p>
<pre><code class="language-text">R0 1,1  1,2  3,3
R1 1,1  1,2  2,3
R2 1,1  1,2  3,3
</code></pre>
<ul>
<li>R0 to R1 append_entries: <code>entries=[{1,2}], prev_log_id = {1,1}, commit_index = 3</code></li>
<li>R1 accepted this append-entries request but was not aware of that entry <code>{2,3}</code> is inconsistent to leader.
Then it will update commit_index to <code>3</code> and apply <code>{2,3}</code></li>
</ul>
<h2 id="replication-by-sending-snapshot"><a class="header" href="#replication-by-sending-snapshot">Replication by sending snapshot</a></h2>
<p>Replication by sending a snapshot of the state machine can be seen as a special form of <strong>appending logs</strong>.
Thus, it shares the same constrains.</p>
<p>A state machine will never be overridden by logs,
thus committed log in it will never get lost.
Thus, when installing a snapshot, it does not need to remove inconsistent logs,
e.g., any log after the <code>last_applied</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
