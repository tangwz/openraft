<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>openraft</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The openraft user guide.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="guide/src/custom.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="cluster-controls.html"><strong aria-hidden="true">2.</strong> Cluster Controls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cluster-formation.html"><strong aria-hidden="true">2.1.</strong> Cluster Formation</a></li><li class="chapter-item expanded "><a href="dynamic-membership.html"><strong aria-hidden="true">2.2.</strong> Dynamic Membership</a></li></ol></li><li class="chapter-item expanded "><a href="metrics.html"><strong aria-hidden="true">3.</strong> Metrics</a></li><li class="chapter-item expanded "><a href="internal.html"><strong aria-hidden="true">4.</strong> Internal</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">4.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="threading.html"><strong aria-hidden="true">4.2.</strong> Threads</a></li><li class="chapter-item expanded "><a href="replication.html"><strong aria-hidden="true">4.3.</strong> Replication</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">openraft</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="openraft"><a class="header" href="#openraft">Openraft</a></h1>
<strong>
    Advanced <a href="https://raft.github.io/">Raft</a> using <a href="https://tokio.rs/">the Tokio framework</a>. Please ‚≠ê on <a href="https://github.com/datafuselabs/openraft">github</a>!
</strong>
<hr />
<p><a href="https://github.com/datafuselabs/openraft/actions/workflows/ci.yaml"><img src="https://github.com/datafuselabs/openraft/actions/workflows/ci.yaml/badge.svg" alt="CI" /></a>
<a href="https://crates.io/crates/openraft"><img src="https://img.shields.io/crates/v/openraft.svg" alt="Crates.io" /></a>
<a href="https://docs.rs/openraft"><img src="https://docs.rs/openraft/badge.svg" alt="docs.rs" /></a>
<a href="LICENSE"><img src="https://img.shields.io/badge/license-MIT%2FApache--2.0-blue" alt="License" /></a>
<img src="https://img.shields.io/crates/d/openraft.svg" alt="Crates.io" />
<img src="https://img.shields.io/crates/dv/openraft.svg" alt="Crates.io" /></p>
<p>Raft is not yet good enough.
This project intends to improve raft as the next generation consensus protocol for distributed data storage systems (SQL, NoSQL, KV, Streaming, Graph ... or maybe something more exotic).</p>
<p>Currently openraft is the consensus engine of meta-service cluster in <a href="https://github.com/datafuselabs/databend">databend</a>.</p>
<ul>
<li>
<p><strong>Get started</strong>: <a href="https://datafuselabs.github.io/openraft">The guide</a> is the best place to get started,
followed by <a href="https://docs.rs/openraft/latest/">the docs</a> for more in-depth details.</p>
</li>
<li>
<p><strong>Openraft API is not stable yet.</strong> Before <code>1.0.0</code>, an upgrade may contain incompatible changes.
Check our <a href="https://github.com/datafuselabs/openraft/blob/main/change-log.md">change-log</a></p>
</li>
<li>
<p>Openraft is derived from <a href="https://docs.rs/crate/async-raft/latest">async-raft</a> with several bugs fixed:</p>
</li>
</ul>
<details>
  <summary>List of fixed bugs:</summary>
<ul>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/6c0ccaf3ab3f262437d8fc021d4b13437fa4c9ac">6c0ccaf3</a> consider joint config when starting up and committing.; by drdr xp; 2021-12-24</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/228077a66d5099fd404ae9c68f0977e5f978f102">228077a6</a> a restarted follower should not wait too long to elect. Otherwise, the entire cluster hangs; by drdr xp; 2021-11-19</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/a48a3282c58bdcae3309545a06431aecf3e65db8">a48a3282</a> handle-vote should compare last_log_id in dictionary order, not in vector order; by drdr xp; 2021-09-09</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/eed681d57950fc58b6ca71a45814b8f6d2bb1223">eed681d5</a> race condition of concurrent snapshot-install and apply.; by drdr xp; 2021-09-01</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/9540c904da4ae005baec01868e01016f3bc76810">9540c904</a> when append-entries, deleting entries after prev-log-id causes committed entry to be lost; by drdr xp; 2021-08-31</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/6d53aa12f66ecd08e81bcb055eb17387b835e2eb">6d53aa12</a> too many(50) inconsistent log should not live lock append-entries; by drdr xp; 2021-08-31</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/4d58a51e41189acba06c1d2a0e8466759d9eb785">4d58a51e</a> a non-voter not in joint config should not block replication; by drdr xp; 2021-08-31</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/8cd24ba0f0212e94e61f21a7be0ce0806fcc66d5">8cd24ba0</a> RaftCore.entries_cache is inconsistent with storage. removed it.; by drdr xp; 2021-08-23</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/2eccb9e1f82f1bf71f6a2cf9ef6da7bf6232fa84">2eccb9e1</a> install snapshot req with offset GE 0 should not start a new session.; by drdr xp; 2021-08-22</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/eee8e534e0b0b9abdb37dd94aeb64dc1affd3ef7">eee8e534</a> snapshot replication does not need to send a last 0 size chunk; by drdr xp; 2021-08-22</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/beb0302b4fec0758062141e727bf1bbcfd4d4b98">beb0302b</a> leader should not commit when there is no replication to voters.; by drdr xp; 2021-08-18</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/dba24036cda834e8c970d2561b1ff435afd93165">dba24036</a> after 2 log compaction, membership should be able to be extract from prev compaction log; by drdr xp; 2021-07-14</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/447dc11cab51fb3b1925177d13e4dd89f998837b">447dc11c</a> when finalize_snapshot_installation, memstore should not load membership from its old log that are going to be overridden by snapshot.; by drdr xp; 2021-07-13</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/cf4badd0d762757519e2db5ed2f2fc65c2f49d02">cf4badd0</a> leader should re-create and send snapshot when <code>threshold/2 &lt; last_log_index - snapshot &lt; threshold</code>; by drdr xp; 2021-07-08</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/d60f1e852d3e5b9455589593067599d261f695b2">d60f1e85</a> client_read has using wrong quorum=majority-1; by drdr xp; 2021-07-02</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/11cb5453e2200eda06d26396620eefe66b169975">11cb5453</a> doc-include can only be used in nightly build; by drdr xp; 2021-06-16</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/a10d99066b8c447d7335c7f34e08bd78c4b49f61">a10d9906</a> when handle_update_match_index(), non-voter should also be considered, because when member change a non-voter is also count as a quorum member; by drdr xp; 2021-06-16</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/d882e743db4734b2188b137ebf20c0443cf9fb49">d882e743</a> when calc quorum, the non-voter should be count; by drdr xp; 2021-06-02</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/6202138f0766dcfd07a1a825af165f132de6b920">6202138f</a> a conflict is expected even when appending empty entries; by drdr xp; 2021-05-24</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/f449b64aa9254d9a18bc2abb5f602913af079ca9">f449b64a</a> discarded log in replication_buffer should be finally sent.; by drdr xp; 2021-05-22</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/6d680484ee3e352d4caf37f5cd6f57630f46d9e2">6d680484</a> #112 : when a follower is removed, leader should stop sending log to it.; by drdr xp; 2021-05-21</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/89bb48f8702762d33b59a7c9b9710bde4a97478c">89bb48f8</a> last_applied should be updated only when logs actually applied.; by drdr xp; 2021-05-20</li>
<li>Fixed: <a href="https://github.com/datafuselabs/openraft/commit/39690593a07c6b9ded4b7b8f1aca3191fa7641e4">39690593</a> a NonVoter should stay as NonVoter instead of Follower after restart; by drdr xp; 2021-05-14</li>
</ul>
<p>A full list of changes/fixes can be found in <a href="https://github.com/datafuselabs/openraft/blob/main/change-log.md">change-log</a></p>
</details>
<h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<p><a href="https://datafuselabs.github.io/openraft/dynamic-membership.html#the-safe-to-relation">Extended joint membership</a></p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Reduce the complexity of vote and pre-vote: <a href="https://github.com/datafuselabs/openraft/discussions/15">get rid of pre-vote RPC</a>;</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Reduce confliction rate when electing;
Allow leadership to be taken in one term by a node with greater node-id.</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Support flexible quorum, e.g.:<a href="https://zookeeper.apache.org/doc/r3.5.9/zookeeperHierarchicalQuorums.html">Hierarchical Quorums</a></p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Consider introducing read-quorum and write-quorum,
improve efficiency with a cluster with an even number of nodes.</p>
</li>
</ul>
<!--
   - - [ ] Consider to separate log storage and log order storage.
   -   Leader only determines and replicates the index of log entries, not log
   -   payload.
   -->
<h1 id="features"><a class="header" href="#features">Features</a></h1>
<ul>
<li>
<p>It is fully reactive and embraces the async ecosystem.
It is driven by actual Raft events taking place in the system as opposed to being driven by a <code>tick</code> operation.
Batching of messages during replication is still used whenever possible for maximum throughput.</p>
</li>
<li>
<p>Storage and network integration is well defined via two traits <code>RaftStorage</code> &amp; <code>RaftNetwork</code>.
This provides applications maximum flexibility in being able to choose their storage and networking mediums.</p>
</li>
<li>
<p>All interaction with the Raft node is well defined via a single public <code>Raft</code> type, which is used to spawn the Raft async task, and to interact with that task.
The API for this system is clear and concise.</p>
</li>
<li>
<p>Log replication is fully pipelined and batched for optimal performance.
Log replication also uses a congestion control mechanism to help keep nodes up-to-date as efficiently as possible.</p>
</li>
<li>
<p>It fully supports dynamic cluster membership changes with joint config.
The buggy single-step membership change algo is not considered.
See the <a href="https://datafuselabs.github.io/openraft/dynamic-membership.html"><code>dynamic membership</code></a> chapter in the guide.</p>
</li>
<li>
<p>Details on initial cluster formation, and how to effectively do so from an application's perspective,
are discussed in the <a href="https://datafuselabs.github.io/openraft/cluster-formation.html">cluster formation</a> chapter in the guide.</p>
</li>
<li>
<p>Automatic log compaction with snapshots, as well as snapshot streaming from the leader node to follower nodes is fully supported and configurable.</p>
</li>
<li>
<p>The entire code base is <a href="https://docs.rs/tracing/">instrumented with tracing</a>.
This can be used for <a href="https://docs.rs/tracing/latest/tracing/index.html#log-compatibility">standard logging</a>, or for <a href="https://docs.rs/tracing/latest/tracing/index.html#related-crates">distributed tracing</a>, and the verbosity can be <a href="https://docs.rs/tracing/latest/tracing/level_filters/index.html">statically configured at compile time</a> to completely remove all instrumentation below the configured level.</p>
</li>
</ul>
<h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Check out the <a href="https://github.com/datafuselabs/openraft/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a> guide for more details on getting started with contributing to this project.</p>
<h1 id="license"><a class="header" href="#license">License</a></h1>
<p>Openraft is licensed under the terms of the MIT License or the Apache License 2.0, at your choosing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In this chapter we are going to build a key-value store cluster with <a href="https://github.com/datafuselabs/openraft">openraft</a>.</p>
<p><a href="https://github.com/datafuselabs/openraft/tree/main/example-raft-kv">example-raft-kv</a>
is the complete example application including the server, the client and a demo cluster.</p>
<hr />
<p>Raft is a distributed consensus protocol designed to manage a replicated log containing state machine commands from clients.</p>
<p>
    <img style="max-width:600px;" src="./images/raft-overview.png"/>
</p>
<p>Raft includes two major parts:</p>
<ul>
<li>How to replicate logs consistently among nodes,</li>
<li>and how to consume the logs, which is defined mainly in state machine.</li>
</ul>
<p>To implement your own raft based application with openraft is quite easy, which
includes:</p>
<ul>
<li>Define client request and response;</li>
<li>Implement a storage to let raft store its state;</li>
<li>Implement a network layer for the raft to transmit messages.</li>
</ul>
<h2 id="1-define-client-request-and-response"><a class="header" href="#1-define-client-request-and-response">1. Define client request and response</a></h2>
<p>A request is some data that modifies the raft state machine.
A response is some data that the raft state machine returns to the client.</p>
<p>Request and response can be any types that impl <code>AppData</code> and <code>AppDataResponse</code>,
e.g.:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ExampleRequest {/* fields */}
impl AppData for ExampleRequest {}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ExampleResponse(Result&lt;Option&lt;String&gt;, ClientError&gt;);
impl AppDataResponse for ExampleResponse {}
<span class="boring">}
</span></code></pre></pre>
<p>These two types are totally application-specific and are mainly related to the
state machine implementation in <code>RaftStorage</code>.</p>
<h2 id="2-implement-raftstorage"><a class="header" href="#2-implement-raftstorage">2. Implement <code>RaftStorage</code></a></h2>
<p>The trait <code>RaftStorage</code> defines the way that data is stored and consumed.
It could be a wrapper of some local KV store such <a href="https://docs.rs/rocksdb/latest/rocksdb/">RocksDB</a>
or a wrapper of a remote SQL DB.</p>
<p><code>RaftStorage</code> defines four sets of APIs an application needs to implement:</p>
<ul>
<li>
<p>Read/write raft state, e.g., term or vote.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_vote(vote:&amp;Vote)
fn read_vote() -&gt; Result&lt;Option&lt;Vote&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Read/write logs.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_log_state() -&gt; Result&lt;LogState&gt;
fn try_get_log_entries(range) -&gt; Result&lt;Vec&lt;Entry&gt;&gt;

fn append_to_log(entries)

fn delete_conflict_logs_since(since:LogId)
fn purge_logs_upto(upto:LogId)
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Apply log entry to the state machine.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn last_applied_state() -&gt; Result&lt;(Option&lt;LogId&gt;, Option&lt;EffectiveMembership&gt;)&gt;
fn apply_to_state_machine(entries) -&gt; Result&lt;Vec&lt;AppResponse&gt;&gt;
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Building and installing a snapshot.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build_snapshot() -&gt; Result&lt;Snapshot&gt;
fn get_current_snapshot() -&gt; Result&lt;Option&lt;Snapshot&gt;&gt;

fn begin_receiving_snapshot() -&gt; Result&lt;Box&lt;SnapshotData&gt;&gt;
fn install_snapshot(meta, snapshot)
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<p>The APIs have been made quite obvious, and there is a good example
<a href="https://github.com/datafuselabs/openraft/blob/main/example-raft-kv/src/store/mod.rs"><code>ExampleStore</code></a>,
which is a pure-in-memory implementation that shows what should be done when a
method is called.</p>
<h3 id="how-do-i-impl-raftstorage-correctly"><a class="header" href="#how-do-i-impl-raftstorage-correctly">How do I impl RaftStorage correctly?</a></h3>
<p>There is a <a href="https://github.com/datafuselabs/openraft/blob/main/memstore/src/test.rs">Test suite for RaftStorage</a>,
if an implementation passes the test, openraft will work happily with it.</p>
<p>To test your implementation with this suite, just do this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
pub fn test_mem_store() -&gt; anyhow::Result&lt;()&gt; {
  openraft::testing::Suite::test_all(MemStore::new)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="race-condition-about-raftstorage"><a class="header" href="#race-condition-about-raftstorage">Race condition about RaftStorage</a></h3>
<p>In our design, there is at most one thread at a time writing data to it.
But there may be several threads reading from it concurrently,
e.g., more than one replication task reading log entries from the store.</p>
<h3 id="an-implementation-has-to-guarantee-data-durability"><a class="header" href="#an-implementation-has-to-guarantee-data-durability">An implementation has to guarantee data durability.</a></h3>
<p>The caller always assumes a completed write is persistent.
The raft correctness highly depends on a reliable store.</p>
<h2 id="3-impl-raftnetwork"><a class="header" href="#3-impl-raftnetwork">3. impl <code>RaftNetwork</code></a></h2>
<p>Raft nodes need to communicate with each other to achieve consensus about the
logs.
The trait <code>RaftNetwork</code> defines the data transmission requirements.</p>
<p>An implementation of <code>RaftNetwork</code> can be considered as a wrapper that invokes the
corresponding methods of a remote <code>Raft</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait RaftNetwork&lt;D&gt;: Send + Sync + 'static
where D: AppData
{
    async fn send_append_entries(&amp;self, target: NodeId, node:Option&lt;Node&gt;, rpc: AppendEntriesRequest&lt;D&gt;) -&gt; Result&lt;AppendEntriesResponse&gt;;
    async fn send_install_snapshot( &amp;self, target: NodeId, node:Option&lt;Node&gt;, rpc: InstallSnapshotRequest,) -&gt; Result&lt;InstallSnapshotResponse&gt;;
    async fn send_vote(&amp;self, target: NodeId, node:Option&lt;Node&gt;, rpc: VoteRequest) -&gt; Result&lt;VoteResponse&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://github.com/datafuselabs/openraft/blob/main/example-raft-kv/src/network/raft_network_impl.rs">ExampleNetwork</a>
shows how to forward messages to other raft nodes.</p>
<p>And there should be a server endpoint for each of these RPCs.
When the server receives a raft RPC, it just passes it to its <code>raft</code> instance and replies with what returned:
<a href="https://github.com/datafuselabs/openraft/blob/main/example-raft-kv/src/network/raft.rs">raft-server-endpoint</a>.</p>
<p>As a real-world impl, you may want to use <a href="https://github.com/hyperium/tonic">Tonic gRPC</a>.
<a href="https://github.com/datafuselabs/databend/blob/6603392a958ba8593b1f4b01410bebedd484c6a9/metasrv/src/network.rs#L89">databend-meta</a> would be an excellent real-world example.</p>
<h3 id="find-the-address-of-the-target-node"><a class="header" href="#find-the-address-of-the-target-node">Find the address of the target node.</a></h3>
<p>An implementation of <code>RaftNetwork</code> need to connect to the remote raft peer,
through TCP etc.</p>
<p>You have two ways to find the address of a remote peer:</p>
<ol>
<li>
<p>Managing the mapping from node-id to address by yourself.</p>
</li>
<li>
<p><code>openraft</code> allows you to store the additional info in its internal Membership,
which is automatically replicated as regular logs.</p>
<p>To use this feature, you need to pass a <code>Node</code> instance, which contains
address and other info, to <code>Raft::add_learner()</code>:</p>
<ul>
<li>
<p><code>Raft::add_learner(node_id, None, ...)</code> tells <code>openraft</code> to store only node-id
in <code>Membership</code>. The membership data then would be like:</p>
<pre><code class="language-json">&quot;membership&quot;: {
   &quot;learners&quot;: [],
   &quot;configs&quot;: [ [ 1, 2, 3 ] ],
   &quot;nodes&quot;: {}
}
</code></pre>
</li>
<li>
<p><code>Raft::add_learner(node_id, Some(Node::new(&quot;127.0.0.1&quot;)), ...)</code> tells <code>openraft</code>
to store node-id, and its address in <code>Membership</code> too:</p>
<pre><code class="language-json">&quot;membership&quot;: {
   &quot;learners&quot;: [],
   &quot;configs&quot;: [ [ 1, 2, 3 ] ],
   &quot;nodes&quot;: {
     &quot;1&quot;: { &quot;addr&quot;: &quot;127.0.0.1:21001&quot;, &quot;data&quot;: {} },
     &quot;2&quot;: { &quot;addr&quot;: &quot;127.0.0.1:21002&quot;, &quot;data&quot;: {} },
     &quot;3&quot;: { &quot;addr&quot;: &quot;127.0.0.1:21003&quot;, &quot;data&quot;: {} }
   }
}
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="4-put-everything-together"><a class="header" href="#4-put-everything-together">4. Put everything together</a></h2>
<p>Finally, we put these parts together and boot up a raft node
<a href="https://github.com/datafuselabs/openraft/blob/main/example-raft-kv/src/bin/main.rs">main.rs</a>
:</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
  #[actix_web::main]
  async fn main() -&gt; std::io::Result&lt;()&gt; {
    // Setup the logger
    env_logger::init_from_env(Env::default().default_filter_or(&quot;info&quot;));

    // Parse the parameters passed by arguments.
    let options = Opt::parse();
    let node_id = options.id;

    // Create a configuration for the raft instance.
    let config = Arc::new(Config::default().validate().unwrap());

    // Create a instance of where the Raft data will be stored.
    let store = Arc::new(ExampleStore::default());

    // Create the network layer that will connect and communicate the raft instances and
    // will be used in conjunction with the store created above.
    let network = Arc::new(ExampleNetwork {});

    // Create a local raft instance.
    let raft = Raft::new(node_id, config.clone(), network, store.clone());

    // Create an application that will store all the instances created above, this will
    // be later used on the actix-web services.
    let app = Data::new(ExampleApp {
      id: options.id,
      raft,
      store,
      config,
    });

    // Start the actix-web server.
    HttpServer::new(move || {
      App::new()
              .wrap(Logger::default())
              .wrap(Logger::new(&quot;%a %{User-Agent}i&quot;))
              .wrap(middleware::Compress::default())
              .app_data(app.clone())
              // raft internal RPC
              .service(raft::append)
              .service(raft::snapshot)
              .service(raft::vote)
              // admin API
              .service(management::init)
              .service(management::add_learner)
              .service(management::change_membership)
              .service(management::metrics)
              .service(management::list_nodes)
              // application API
              .service(api::write)
              .service(api::read)
    })
            .bind(options.http_addr)?
            .run()
            .await
  }
}

</code></pre></pre>
<h2 id="5-run-the-cluster"><a class="header" href="#5-run-the-cluster">5. Run the cluster</a></h2>
<p>To set up a demo raft cluster includes:</p>
<ul>
<li>Bring up three uninitialized raft nodes;</li>
<li>Initialize a single-node cluster;</li>
<li>Add more raft nodes into it;</li>
<li>Update the membership config.</li>
</ul>
<p><a href="https://github.com/datafuselabs/openraft/tree/main/example-raft-kv">example-raft-kv</a> describes these steps in detail.</p>
<p>And two test scripts for setting up a cluster are provided:</p>
<ul>
<li>
<p><a href="https://github.com/datafuselabs/openraft/blob/main/example-raft-kv/test-cluster.sh">test-cluster.sh</a>
is a minimized bash script using curl to communicate with the raft cluster,
to show what messages are sent and received in plain HTTP.</p>
</li>
<li>
<p><a href="https://github.com/datafuselabs/openraft/blob/main/example-raft-kv/tests/cluster/test_cluster.rs">test_cluster.rs</a>
Use ExampleClient to set up a cluster, write data, and then read it.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cluster-controls"><a class="header" href="#cluster-controls">Cluster Controls</a></h1>
<p>A raft cluster may be controlled in various ways using the API methods of the <code>Raft</code> type.
This allows the application to influence the raft behavior.</p>
<p>There are several concepts related to cluster control:</p>
<ul>
<li>
<p>Voter: a raft node that is responsible to vote, elect itself for leadership(Candidate),
become Leader or Follower</p>
</li>
<li>
<p>Candidate: a node tries to elect itself as the Leader.</p>
</li>
<li>
<p>Leader: the only node in a cluster that deals with application request.</p>
</li>
<li>
<p>Follower: a node that believes there is a legal leader and just receives
replicated logs.</p>
</li>
<li>
<p>Learner: a node that is not allow to vote but only receives logs.</p>
</li>
</ul>
<p>Voter state transition:</p>
<pre><code>                         vote granted by a quorum
          .--&gt; Candidate ----------------------&gt; Leader
heartbeat |     |                                  |
timeout   |     | seen a higher Leader             | seen a higher Leader
          |     v                                  |
          '----Follower &lt;--------------------------'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cluster-formation"><a class="header" href="#cluster-formation">Cluster Formation</a></h1>
<p>A <code>Raft</code> node enters <code>Learner</code> state when it is created by <code>Raft::new()</code>.</p>
<p>To form a cluster, application must call <code>Raft::initialize(membership)</code>.</p>
<h2 id="raftinitialize"><a class="header" href="#raftinitialize"><code>Raft::initialize()</code></a></h2>
<p>This method will:</p>
<ul>
<li>
<p>Update the in-memory membership.</p>
</li>
<li>
<p>If there are more than one voters in the config, enter Candidate state and start vote to become leader.</p>
</li>
<li>
<p>If there is only one voters(itself) in the config, become leader at once and
will enter leader state.</p>
</li>
<li>
<p>The leader will commit a log contains the given membership config.</p>
</li>
</ul>
<p>TODO(xp): this procedure will be changed:  https://github.com/datafuselabs/openraft/issues/45</p>
<ul>
<li>
<p>Calling this method on an already initialized node just returns an error and is safe.</p>
</li>
<li>
<p>Calling this method on more than one node at the same time:</p>
<ul>
<li>
<p>with the same <code>membership</code> is safe.
Because voting protocol guarantees consistency.</p>
</li>
<li>
<p>with different <code>membership</code> is <strong>ILLEGAL</strong> and will result in a undefined
state, AKA the <strong>split-brain</strong> state.</p>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-membership"><a class="header" href="#dynamic-membership">Dynamic Membership</a></h1>
<p>Unlike the original raft, openraft treats all membership as a <strong>joint</strong> membership.
A uniform config is just a special case of joint: the joint of only one config.</p>
<p>Openraft offers two mechanisms for controlling member node lifecycle:</p>
<h2 id="raftadd_learner"><a class="header" href="#raftadd_learner"><code>Raft::add_learner()</code></a></h2>
<p>This method will add a learner to the cluster,
and immediately begin syncing logs from the leader.</p>
<ul>
<li>
<p>A <strong>Learner</strong> won't vote for leadership.</p>
</li>
<li>
<p>A <strong>Learner</strong> is not persistently stored by <code>Raft</code>, i.e., if a new leader is
elected, a Learner will no longer receive logs from the new leader.</p>
</li>
</ul>
<h2 id="raftchange_membershipnode_list-turn_to_learner"><a class="header" href="#raftchange_membershipnode_list-turn_to_learner"><code>Raft::change_membership(node_list, turn_to_learner)</code></a></h2>
<p>This method will initiate a membership change and returns when the effective
membership becomes <code>node_list</code>.</p>
<p>If there are nodes in the given membership that is not a <code>Learner</code>, this method will add it
as Learner first.
Thus it is recommended that the application always call <code>Raft::add_learner</code> first.
Otherwise, <code>Raft::change_membership</code> may block for long before committing the
given membership and return.</p>
<p>Once the new membership is committed, whether or not a <code>Voter</code> that is not in the new membership will
revert to a <code>Learner</code> is base on the <code>turn_to_learner</code>.</p>
<p>If <code>turn_to_learner</code> is true, then all the members which not exists in the new membership,
will be turned into learners, otherwise will be removed.</p>
<p>Example of <code>turn_to_learner</code> usage:
If the original membership is {&quot;members&quot;:{1,2,3}, &quot;learners&quot;:{}}, and call <code>change_membership</code> 
with <code>node_list</code> {3,4,5}, then:
- If <code>turn_to_learner</code> is true, after commit the new membership is {&quot;members&quot;:{3,4,5}, &quot;learners&quot;:{1,2}}.
- Otherwise if <code>turn_to_learner</code> is false, then the new membership is {&quot;members&quot;:{3,4,5}, &quot;learners&quot;:{}}, 
in which the members not exists in the new membership just be removed from the cluster.</p>
<h2 id="extended-membership-change-algo"><a class="header" href="#extended-membership-change-algo">Extended membership change algo</a></h2>
<p>Openraft tries to commit one or more membership logs to finally change the
membership to <code>node_list</code>.
In every step, the log it tries to commit is:</p>
<ul>
<li>
<p>the <code>node_list</code> itself, if it is safe to change from previous membership to
<code>node_list</code> directly.</p>
</li>
<li>
<p>otherwise, a <strong>joint</strong> of the specified <code>node_list</code> and one config in the
previous membership.</p>
</li>
</ul>
<p>This algo that openraft uses is the so-called <strong>Extended membership change</strong>.</p>
<blockquote>
<p>It is a more generalized form of membership change.
The original 2-step <strong>joint</strong> algo and 1-step algo in raft-paper are all specialized versions of this algo.</p>
</blockquote>
<p>This algo provides more flexible membership change than the original joint algo:</p>
<ul>
<li>
<p>The original <strong>Joint</strong> algo:</p>
<p>The original <strong>joint</strong> algo in raft-paper allows changing membership in an
alternate pattern of joint membership and uniform membership.
E.g.,  the membership entry in a log history could be:</p>
<p><code>c1</code>  ‚Üí  <code>c1c2</code>  ‚Üí  <code>c2</code>  ‚Üí  <code>c2c3</code>  ‚Üí  <code>c3</code>  ...</p>
<p>Where:</p>
<ul>
<li><code>c·µ¢</code> is a uniform membership, such as <code>{a, b, c}</code>;</li>
<li><code>c·µ¢c‚±º</code> is a joint of two node lists, such as <code>[{a, b, c}, {x, y, z}]</code>.</li>
</ul>
</li>
<li>
<p><strong>Extended</strong> algo:</p>
<p>Extended membership change algo allows changing membership in the
following way:</p>
<p><code>c1</code>  ‚Üí  <code>c1c2c3</code>  ‚Üí  <code>c3c4</code>  ‚Üí  <code>c4</code>.</p>
<p>Or revert to a previous membership:</p>
<p><code>c1c2c3</code>  ‚Üí  <code>c1</code>.</p>
</li>
</ul>
<h4 id="flexibility"><a class="header" href="#flexibility">Flexibility</a></h4>
<p>Another example shows that it is always safe to change membership from one
to another along the edges in the following diagram:</p>
<pre><code class="language-text">          c3
         /  \
        /    \
       /      \
   c1c3 ------ c2c3
    / \        / \
   /   \      /   \
  /     \    /     \
c1 ----- c1c2 ----- c2
</code></pre>
<h4 id="disjoint-memberships"><a class="header" href="#disjoint-memberships">Disjoint memberships</a></h4>
<p>A counter-intuitive conclusion is that:</p>
<p><strong>Even when two leaders propose two memberships without intersection, consensus will
still, be achieved</strong>.</p>
<p>E.g., given the current membership to be <code>c1c2</code>, if
<code>L1</code> proposed <code>c1c3</code>,
<code>L2</code> proposed <code>c2c4</code>.</p>
<p>There won't be a brain split problem.</p>
<h4 id="spec-of-extended-membership-change-algo"><a class="header" href="#spec-of-extended-membership-change-algo">Spec of extended membership change algo</a></h4>
<p>This algo requires four constraints to work correctly:</p>
<ul>
<li>
<p>(0) <strong>use-at-once</strong>:
The new membership that is appended to log will take effect at once, i.e., openraft
uses the last seen membership config in the log, no matter it is committed or not.</p>
</li>
<li>
<p>(1) <strong>propose-after-commit</strong>:
A leader is allowed to propose new membership only when the previous one is
committed.</p>
</li>
<li>
<p>(2) <strong>old-new-intersect</strong>(safe transition):
(This is the only constraint that is loosened from the original raft) Any
quorum in new membership(<code>m'</code>) intersect with any quorum in the old
committed membership(<code>m</code>):</p>
<p><code>‚àÄq·µ¢ ‚àà m, ‚àÄq‚±º ‚àà m'</code>: <code>q·µ¢ ‚à© q‚±º ‚â† √∏</code>.</p>
</li>
<li>
<p>(3) <strong>initial-log</strong>:
A leader has to replicate an initial blank log to a quorum in last seen
membership to commit all previous logs.</p>
</li>
</ul>
<p>In our implementation, (2) <strong>old-new-intersect</strong> is simplified to:
The new membership has to contain a config entry that is the same as one in the last
committed membership.</p>
<p>E.g., given the last committed one is <code>[{a, b, c}]</code>, then a valid new membership may be:
a joint membership: <code>[{a, b, c}, {x, y, z}]</code>.</p>
<p>If the last committed one is <code>[{a, b, c}, {x, y, z}]</code>, a valid new membership
may be: <code>[{a, b, c}]</code>, or <code>[{x, y, z}]</code>.</p>
<h3 id="proof-of-correctness"><a class="header" href="#proof-of-correctness">Proof of correctness</a></h3>
<p>Assumes there was a brain split problem occurred,
then there are two leaders(<code>L1</code> and <code>L2</code>) proposing different membership(<code>m1</code> and <code>m2</code>(<code>m·µ¢ = c·µ¢c‚±º...</code>)):</p>
<p><code>L1</code>: <code>m1</code>,
<code>L2</code>: <code>m2</code></p>
<p>Thus the <code>L1</code> log history and the <code>L2</code> log history diverged.
Let <code>m0</code> be the last common membership in the log histories:</p>
<pre><code class="language-text">L1       L2

m1       m2
 \      /
  \    o   term-2
   \   |
    `--o   term-1
       |
       m0
</code></pre>
<p>From (1) <strong>propose-after-commit</strong>,</p>
<ul>
<li><code>L1</code> must have committed log entry <code>m0</code> to a quorum in <code>m0</code>  in <code>term_1</code>.</li>
<li><code>L2</code> must have committed log entry <code>m0</code> to a quorum in <code>m0</code>, in <code>term_2</code>.</li>
</ul>
<p>Assumes <code>term_1 &lt; term_2</code>.</p>
<p>From (3) <strong>initial-log</strong>, <code>L2</code> has at least one log with <code>term_2</code> committed in a
quorum in <code>m0</code>.</p>
<p>‚àµ (2) <strong>old-new-intersect</strong> and <code>term_1 &lt; term_2</code></p>
<p>‚à¥ log entry <code>m1</code> can never be committed by <code>L1</code>, 
because log replication or voting will always see a higher <code>term_2</code> on a node in a quorum in <code>m0</code>.</p>
<p>For the same reason, a candidate with log entry <code>m1</code> can never become a leader.</p>
<p>‚à¥ It is impossible that there are two leaders that both can commit a log entry.</p>
<p>QED.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics"><a class="header" href="#metrics">Metrics</a></h1>
<p><code>Raft</code> exports metrics on its internal state via <code>Raft::metrics() -&gt; watch::Receiver&lt;RaftMetrics&gt;</code>.</p>
<p><code>RaftMetrics</code> contains useful information such as:</p>
<ul>
<li>role of this raft node,</li>
<li>the current leader,</li>
<li>last, committed, applied log.</li>
<li>replication state, if this node is a Leader,</li>
<li>snapshot state,</li>
</ul>
<p>Metrics can be used as a trigger of application events, as a monitoring data
source, etc.</p>
<p>Metrics is not a stream thus it only guarantees to provide the latest state but
not every change of the state.
Because internally, <code>watch::channel()</code> only stores one state.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal"><a class="header" href="#internal">Internal</a></h1>
<p>In this chapter we explains how openraft internally works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<pre><code class="language-bob">
        .~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~.
        !          User                   !
        !          o                      !
        !          |                      !
        !          |                      !
        !          | &quot;client_write(impl AppData) -&gt; impl AppDataResponse&quot;
        !          | &quot;is_leader()&quot;        !
        !          | &quot;add_learner()&quot;      !
        !          | &quot;change_membership()&quot;!
        !          v                      !
        !          Raft                   !             .-------------&gt; Raft -----.
        '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'             |                         |
                   |                                    |                         |
                   | enum RaftMes                       |                         |
                   |                                    |                         |
           .~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~.    |                         |
           !       v                               !    | RPC:                    v
.----------------o RaftCore                        !    |   &quot;vote()&quot;              RaftCore
|          !          o                            !    |   &quot;append_entries()&quot;
|          !       .--+--------.                   !    |   &quot;install_snapshot()&quot;
|          !       v           v                   !    |
|          ! ReplicationState  ReplicationState    !    |
|          '~~|~~~~~~~~~~~~~~~~|~~~~~~~~~~~~~~~~~~~'    |
|             |                |                        |
|             |                |                        |
|  .~~~~~~~~~~|~~~~~~~~~~.  .~~|~~~~~~~~~~~~~~~~~~~.    |
|  !          v          !  !  v                   !    |
|  ! ReplicationStream   !  !  ReplicationStream   !    |
|  ! o                   !  !  o  o                !    |
|  '~|~~~~~~~~~~~~~~~~~~~'  !  |  |                !    |
|    |                      !  |  v                !    |
|    |                      !  |  Arc&lt;RaftNetwork&gt; -----'
|    |                      '~~|~~~~~~~~~~~~~~~~~~~'
|    |                         |
|    `-------------------------+
|                              | &quot;get_log()&quot;
|                              | &quot;...&quot;
|                              v
`----------------------&gt; Arc&lt;RaftStorage&gt;
   &quot;append_log()&quot;              o
   &quot;...&quot;                       |
                               v
                           local-disk


 -----------------------------------------------              -----------------------------------------------
 Node 1                                                       Node 2

Legends:

.~~~~~~~~~~~~~~.
! &quot;tokio task&quot; !
'~~~~~~~~~~~~~~'

o--&gt; function call
---&gt; async communication: through channel or RPC
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threadstasks"><a class="header" href="#threadstasks">Threads(tasks)</a></h1>
<p>There are several threads, AKA tokio-tasks in this raft impl:</p>
<ul>
<li>
<p>RaftCore: all logs and state machine operations are done in this thread.
Thus there is no race condition</p>
<ul>
<li>All raft state runs in this task, such as LeaderState, CandidateState etc.</li>
<li>All write to store is done in this task, i.e., write to store is serialized.</li>
</ul>
<p>Lifecycle:</p>
<ul>
<li>RaftCore thread is spawnd when a raft node is created and keeps running until
the raft node is dropped.</li>
</ul>
</li>
<li>
<p>Replication tasks:</p>
<p>There is exactly one replication task spawned for every replication target,
i.e., a follower or learner.</p>
<p>A replication task replicates logs or snapshot to its target.
A replication thread do not write logs or state machine, but only read from it.</p>
<p>Lifecycle:</p>
<ul>
<li>
<p>A replication task is spawned when RaftCore enters <code>LeaderState</code>, or a leader
target is added by user.</p>
</li>
<li>
<p>A replication task is dropped when a follower of learner is removed by
<strong>change-membership</strong> or when RaftCore quits <code>LeaderState</code>.</p>
</li>
</ul>
</li>
<li>
<p>Snapshot building task:</p>
<p>When RaftCore receives a RaftMsg that requires a snapshot, which is sent by a
<strong>replication task</strong>, RaftCore spawns a sub task to build a snapshot.</p>
<p>Lifecycle:</p>
<ul>
<li>It is spawned when a snapshot is requested,
and is dropped at once when the snapshot is ready.</li>
</ul>
</li>
<li>
<p>User application runs in another task that spawns RaftCore task.</p>
</li>
</ul>
<h1 id="communication-between-tasks"><a class="header" href="#communication-between-tasks">Communication between tasks</a></h1>
<p>All tasks communicate with channels:</p>
<pre><code>User
|
| write;
| change_membership;
| ...
|
|                     new log to
|                     replicate;
`---------&gt; RaftCore -------------+-&gt; Replication -.
            ^  ^                  |                |
            |  |                  `-&gt; Replication -+
            |  |                                   |
            |  `-----------------------------------'
            |      update replication state;
            |      need snapshot;
            |
            |
            | snapshot is ready;
            |
            Build-snapshot

</code></pre>
<ul>
<li>
<p>User to RaftCore: <code>Raft</code> sends <code>RaftMsg</code> though <code>Raft.tx_api</code> to <code>RaftCore</code>,
along with a channel for <code>RaftCore</code> to send back response.</p>
</li>
<li>
<p>RaftCore to Replication: <code>RaftCore</code> stores a channel for every repliation
task.
The messages sent to replication task includes:</p>
<ul>
<li>a new log id to replicate,</li>
<li>and the index the leader has committed.</li>
</ul>
</li>
<li>
<p>Replication to RaftCore:</p>
<ul>
<li>
<p>Replication task sends the already replicated log id
to RaftCore through another per-replication channel.</p>
</li>
<li>
<p>Replication task sends a <code>NeedSnapshot</code> request through the same channel to
ask RaftCore to build a snapshot if there is no log a follower/learner
needs.</p>
</li>
</ul>
</li>
<li>
<p>Build-snapshot to RaftCore: RaftCore spawn a separate task to build a snapshot
asynchronously. When finished, the spawned task sends to RaftCore a message
including the snapshot info.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="replication"><a class="header" href="#replication">Replication</a></h1>
<p>Appending entry is the only RPC to replicate logs from leader to followers or learners.
Installing a snapshot can be seen as a special form of <strong>appending logs</strong>.</p>
<h2 id="append-entry"><a class="header" href="#append-entry">Append-entry</a></h2>
<p>Raft logs can be together seen as a <strong>single value</strong>:
An append-entry RPC forwards all logs to a follower and replace all the logs on the follower.
This way it guarantees committed log can always been seen by next leader.</p>
<p>Although in practice, it is infeasible sending all the logs in one RPC.
Thus, the receiving end in the algorithm becomes:</p>
<ul>
<li>Proceed only when <code>prev_log_id</code> matches local log id at the same <code>index</code>.</li>
<li>Save every log entry into local store if:
<ul>
<li>the entry at the target index is empty.</li>
<li>the entry at the target index is the same as the input one.
Otherwise, there is an <strong>inconsistent</strong> entry,
the follower must delete all entries since this one before storing the input one.</li>
</ul>
</li>
</ul>
<h3 id="why-need-to-delete"><a class="header" href="#why-need-to-delete">Why need to delete</a></h3>
<p>The following diagram shows only log term.</p>
<pre><code class="language-text">R1 5
R2 5
R3 5 3 3
R4
R5 2 4 4
</code></pre>
<p>If log 5 is committed by R1, and log 3 is not removed, R5 in future could become a new leader and overrides log
5 on R3.</p>
<h3 id="caveat-deleting-all-entries-after-prev_log_id-get-committed-log-lost"><a class="header" href="#caveat-deleting-all-entries-after-prev_log_id-get-committed-log-lost">Caveat: deleting all entries after <code>prev_log_id</code> get committed log lost</a></h3>
<p>One of the mistake is to delete all entries after <code>prev_log_id</code> when a matching <code>prev_log_id</code> is found, e.g.:</p>
<pre><code>fn handle_append_entries(req) {
    if store.has(req.prev_log_id) {
        store.delete_logs(req.prev_log_id.index..)
        store.append_logs(req.entries)
    }
}

</code></pre>
<p>This results in loss of committed entry, because deleting and appending are not atomically executed.</p>
<p>E.g., the log entries are as following and R1 now is the leader:</p>
<pre><code class="language-text">R1 1,1  1,2  1,3
R2 1,1  1,2
R3
</code></pre>
<p>When the following steps take place, committed entry <code>{1,2}</code> is lost:</p>
<ul>
<li>R1 to R2: <code>append_entries(entries=[{1,2}, {1,3}], prev_log_id={1,1})</code></li>
<li>R2 deletes <code>{1,2}</code></li>
<li>R2 crash</li>
<li>R2 elected as leader and only see <code>{1,1}</code>; the committed entry <code>{1,2}</code> is lost.</li>
</ul>
<p><strong>The safe way is to skip every entry that present in append-entries message then delete only the
inconsistent entries</strong>.</p>
<h3 id="caveat-commit-index-must-not-advance-the-last-known-consistent-log"><a class="header" href="#caveat-commit-index-must-not-advance-the-last-known-consistent-log">Caveat: commit-index must not advance the last known consistent log</a></h3>
<p>Because we can not just delete <code>log[prev_log_id.index..]</code>, (which results in loss of committed
entry), the commit index must be updated only after append-entries
and must point to a log entry that is consistent to the leader.
Or there would be chance applying an uncommitted entry on a follower:</p>
<pre><code class="language-text">R0 1,1  1,2  3,3
R1 1,1  1,2  2,3
R2 1,1  1,2  3,3
</code></pre>
<ul>
<li>R0 to R1 append_entries: <code>entries=[{1,2}], prev_log_id = {1,1}, commit_index = 3</code></li>
<li>R1 accepted this append-entries request but was not aware of that entry <code>{2,3}</code> is inconsistent to leader.
Then it will update commit_index to <code>3</code> and apply <code>{2,3}</code></li>
</ul>
<h2 id="replication-by-sending-snapshot"><a class="header" href="#replication-by-sending-snapshot">Replication by sending snapshot</a></h2>
<p>Replication by sending a snapshot of the state machine can be seen as a special form of <strong>appending logs</strong>.
Thus, it shares the same constrains.</p>
<p>A state machine will never be overridden by logs,
thus committed log in it will never get lost.
Thus, when installing a snapshot, it does not need to remove inconsistent logs,
e.g., any log after the <code>last_applied</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
